local Output = warn --// Function used to output remote calls (Change to rconsoleprint to use Synapse's console)
local CustomIgnoreFunction = function(Remote, Method, Arguments) --// If this returns true, then the remote call will not be displayed / recorded (You can edit this)
	return false
end

local Settings = { --// You can change these settings
	Enabled = true, --// Remote spy is enabled
	Copy = false, --// Set remote calls to clipboard as code
	Blacklist = { --// Ignore remote calls made with these remotes
		CharacterSoundEvent = true,
	},
	ShowScript = true, --// Print out the script that made the remote call (Unfunctional with ProtoSmasher)
	ShowReturns = true, --// Display what the remote calls return
	Record = false, --// Save remote calls to a text file (Uses writefile every second to save performance)
	TabCharacter = "    ", --// Character(s) to use between items in tables / tuples (The repetition of this character is calculated)
	NewlineCharacter = "\n" --// Character(s) to use between items in tables / tuples
}

local metatable = getrawmetatable(game)

--// Custom functions aliases

local setreadonly = setreadonly or set_readonly
local make_writeable = make_writeable or function(t)
	setreadonly(t, false)
end
local make_readonly = make_readonly or function(t)
	setreadonly(t, true)
end
local detour_function = detour_function or replace_closure or hookfunction
local setclipboard = setclipboard or set_clipboard or writeclipboard
local get_namecall_method = get_namecall_method or getnamecallmethod
local protect_function = protect_function or newcclosureyield or newcclosure or function(...)
	return ...
end
--// \\--

local Original = {}
local Recorded = ""
local Methods = {
	RemoteEvent = "FireServer",
	RemoteFunction = "InvokeServer"
}
local MethodEnabled = {
    FireServer = false,
    InvokeServer = false,
    namecall = false
}

do --// Handle 'Output' Setting
	Settings = setmetatable(Settings, {
		__newindex = function(self, index, value)
			if index == "Output" then
				Output = value
			elseif index == "CustomIgnoreFunction" or index == "IgnoreFunction" then
				CustomIgnoreFunction = value
			else
				rawset(self, index, value)
			end
		end
	})
end

local function IsValidCall(Remote, Method, Arguments)
	return Settings.Enabled and (Methods[Remote.ClassName] == Method) and not (Settings.Blacklist[Remote.Name] or CustomIgnoreFunction(Remote, Method, Arguments))
end

local function GetInstanceName(Object) --// Returns proper string wrapping for instances
	if Object == nil then
		return ".NIL"
	end
	
	local IsService = Object.Parent == game
	local Name = IsService and Object.ClassName or Object.Name
	
	return (Object ~= game and GetInstanceName(Object.Parent) or "") .. (IsService and ":GetService(\"%s\")" or (#Name == 0 or Name:match("[^%w]+") or Name:sub(1, 1):match("[^%a]")) and "[\"%s\"]" or ".%s"):format(Name)
end

local function Find(Table, Object, LastIndex)
	LastIndex = LastIndex or ""
	
	for Idx, Value in next, Table do
		if Object == Value then
			return LastIndex .. Idx
		elseif type(Value) == "table" then
			local Result = Find(Value, Object, Idx .. ".")
			if Result ~= nil then
				return LastIndex .. Result
			end
		end
	end
end

local renv = getrenv()

local function Parse(Object, TabCount) --// Convert the types into strings
	local Type = typeof(Object)
	local ParsedResult
	local TabCount = TabCount or 0
	
	if Type == "string" then
		ParsedResult = ("\"%s\""):format(Object)
	elseif Type == "Instance" then --// GetFullName except it's not handicapped
		ParsedResult = GetInstanceName(Object):sub(2)
	elseif Type == "table" then
		local Str = ""
		local Counter = 0
		
		TabCount = TabCount + 1
		
		for Idx, Obj in next, Object do
			Counter = Counter + 1
			Obj = Obj == Object and "THIS_TABLE" or Parse(Obj, TabCount)
			local TabCharacter = (Counter > 1 and "," or "") .. Settings.NewlineCharacter .. Settings.TabCharacter:rep(TabCount)
			if Counter ~= Idx then
				Str = Str .. ("%s[%s] = %s"):format(TabCharacter, Idx ~= Object and Parse(Idx, TabCount) or "THIS_TABLE", Obj)	 --maybe
			else
				Str = Str .. ("%s%s"):format(TabCharacter, Obj)
			end
		end
		
		TabCount = TabCount - 1
		ParsedResult = ("{%s}"):format(Str .. (#Str > 0 and Settings.NewlineCharacter .. Settings.TabCharacter:rep(TabCount) or ""))
	elseif Type == "CFrame" or Type == "Vector3" or Type == "Vector2" or Type == "UDim2" or Type == "Color3" or Type == "Vector3int16" or Type == "UDim" or Type == "Vector2int16" then
		ParsedResult = ("%s.new(%s)"):format(Type, tostring(Object))
	elseif Type == "userdata" then --// Remove __tostring fields to counter traps
		local Result
		local Metatable = getrawmetatable(Object)
		local __tostring = Metatable and rawget(Metatable, "__tostring")
		
		if __tostring then
			make_writeable(Metatable)
			Metatable.__tostring = nil
			ParsedResult = tostring(Object)
			rawset(Metatable, "__tostring", __tostring)
			if rawget(Metatable, "__metatable") ~= nil then
				make_readonly(Metatable)
			end
		else
			ParsedResult = tostring(Object)
		end
	elseif Type == "function" then
		ParsedResult = Find(renv, Object) or (
		[[(function()
			for Idx, Value in next, %s() do
				if type(Value) == "function" and tostring(Value) == "%s" then
					return Value
				end
			end
		end)()]]
		):gsub(
			"\n", 
			Settings.NewlineCharacter
		):gsub(
			"\t", 
			Settings.TabCharacter:rep(TabCount)
		):format(
			getgc and "getgc" or get_gc_objects and "get_gc_objects" or "debug.getregistry", 
			tostring(Object)
		)
	else
		ParsedResult = tostring(Object)
	end
	
	return ParsedResult
end

local function Write(Remote, Method, Arguments) --// Remote (Multiple types), Arguments (Table)
	local Stuff = ("\n\n%s:%s(%s)"):format(typeof(Remote) == "Instance" and Parse(Remote) or ("(%s)"):format(Parse(Remote)), Method, Parse(Arguments):sub(2, -2))
	
	if Settings.Copy then
		pcall(setclipboard, Stuff)
	end
	if Settings.ShowScript and not PROTOSMASHER_LOADED then
		local Script = getcallingscript and getcallingscript() or rawget(getfenv(2), "script")
		
		if typeof(Script) == "Instance" then
			Stuff = Stuff .. ("\nScript: %s"):format(Parse(Script))
		end
	end
	if Settings.Record then
		Recorded = Recorded .. Stuff
	end
	
	Output(Stuff) --// Output the remote call
	
	if Method == "FireServer" then
	    warn([[
	    
  █████▒██▓ ██▀███  ▓█████ 
▓██   ▒▓██▒▓██ ▒ ██▒▓█   ▀ 
▒████ ░▒██▒▓██ ░▄█ ▒▒███   
░▓█▒  ░░██░▒██▀▀█▄  ▒▓█  ▄ 
░▒█░   ░██░░██▓ ▒██▒░▒████▒
 ▒ ░   ░▓  ░ ▒▓ ░▒▓░░░ ▒░ ░
 ░      ▒ ░  ░▒ ░ ▒░ ░ ░  ░
 ░ ░    ▒ ░  ░░   ░    ░   
        ░     ░        ░  ░
                           
	        ]])
	elseif Method == "InvokeServer" then
	    warn([[
	    
 ██▓ ███▄    █ ██▒   █▓ ▒█████   ██ ▄█▀▓█████ 
▓██▒ ██ ▀█   █▓██░   █▒▒██▒  ██▒ ██▄█▒ ▓█   ▀ 
▒██▒▓██  ▀█ ██▒▓██  █▒░▒██░  ██▒▓███▄░ ▒███   
░██░▓██▒  ▐▌██▒ ▒██ █░░▒██   ██░▓██ █▄ ▒▓█  ▄ 
░██░▒██░   ▓██░  ▒▀█░  ░ ████▓▒░▒██▒ █▄░▒████▒
░▓  ░ ▒░   ▒ ▒   ░ ▐░  ░ ▒░▒░▒░ ▒ ▒▒ ▓▒░░ ▒░ ░
 ▒ ░░ ░░   ░ ▒░  ░ ░░    ░ ▒ ▒░ ░ ░▒ ▒░ ░ ░  ░
 ▒ ░   ░   ░ ░     ░░  ░ ░ ░ ▒  ░ ░░ ░    ░   
 ░           ░      ░      ░ ░  ░  ░      ░  ░
                   ░                          
	        ]])
	end
end

local CustomGamesSpy = {
	[606849621] = function() --// Jailbreak's custom FireServer
		local Script = game:GetService("Players").LocalPlayer.PlayerScripts.LocalScript
		local RemoteTable
		for Idx, Value in next, debug.getregistry() do
			if type(Value) == "function" and getfenv(Value).script == Script then
				for UpvalIdx, Upval in next, debug.getupvalues(Value) do
					if type(Upval) == "table" and rawget(Upval, "FireServer") then
						RemoteTable = Upval
						
						break
					end
				end
				
				if RemoteTable ~= nil then
					break
				end
			end
		end
		assert(RemoteTable ~= "nil", "Remote not found")
		local ORIG = debug.getupvalues(RemoteTable.FireServer)[1]
		RemoteTable = setmetatable({
			FireServer = RemoteTable.FireServer
		}, {
			__index = {
				ClassName = "RemoteEvent"
			}
		})
		local new_function = function(...)
			local Arguments = {...}
			if IsValidCall(RemoteTable, "FireServer", Arguments) then
				Write(RemoteTable, "FireServer", Arguments)
			end
			return ORIG(...)
		end
		debug.setupvalue(RemoteTable.FireServer, 1, new_function)
	end
}

do --// Anti detection for tostring ( tostring(FireServer, InvokeServer) )
	local original_function = tostring
	local new_function = function(obj)
		local Success, Result = pcall(original_function, Original[obj] or obj)
		
		if Success then
			return Result
		else
			error(Result:gsub(script.Name .. ":%d+: ", ""))
		end
	end
	
	original_function = detour_function(original_function, new_function)
	Original[new_function] = original_function
end

do --// Function hooks
	local CustomSpy = CustomGamesSpy[game.PlaceId]
	
	if CustomSpy then
		CustomSpy()
	else
		for Class, Method in next, Methods do --// FireServer and InvokeServer hooking ( FireServer(Remote, ...) )
			local original_function = Instance.new(Class)[Method]
			local function new_function(self, ...)
				local Arguments = {...}
				
				if typeof(self) == "Instance" and IsValidCall(self, Method, Arguments) then
					Write(self, Method, Arguments)
				end
				
				return original_function(self, ...)
			end
			
			new_function = protect_function(new_function)
			original_function = detour_function(original_function, new_function)
			Original[new_function] = original_function
		end
	end
end

do --// Namecall hooking ( Remote:FireServer(...) )
	if get_namecall_method then
		local __namecall = metatable.__namecall
		local function new_function(self, ...)
			local Arguments = {...}
			local Method = get_namecall_method()
			
			if typeof(Method) == "string" and IsValidCall(self, Method, Arguments) then
			    if MethodEnabled.namecall == true then
				    Write(self, Method, Arguments)
				end
			end
			
			return __namecall(self, ...)
		end
		
		new_function = protect_function(new_function)
		make_writeable(metatable)
		metatable.__namecall = new_function
		make_readonly(metatable)
		Original[new_function] = __namecall
	else
		warn("Could not hook namecall; 'getnamecallmethod' is unsupported by your executor.")
	end
end

-- IU
local IU = loadstring(game:HttpGet("https://raw.githubusercontent.com/araknala/work-released/main/Roblox/Exploits/Libraries/UI/IU.lua"))()

-- window1
local window1 = IU.CreateLib("speye", "theme_warn")

--- window1_tab1
local window1_tab1 = window1:NewTab("functions")
local window1_tab1_section1 = window1_tab1:NewSection("FireServer")
local window1_tab1_section2 = window1_tab1:NewSection("InvokeServer")
local window1_tab1_section3 = window1_tab1:NewSection("namecall")

window1_tab1_section1:NewToggle("hook to console", "logs FireServer the client console (F9)", function(enabled)
    if enabled then
        MethodEnabled.FireServer = true
    else
        MethodEnabled.FireServer = false
    end
end)
window1_tab1_section2:NewToggle("hook to console", "logs InvokeServer the client console (F9)", function(enabled)
    if enabled then
        MethodEnabled.InvokeServer = true
    else
        MethodEnabled.InvokeServer = false
    end
end)
window1_tab1_section3:NewToggle("hook to console", "logs namecall the client console (F9)", function(enabled)
    if enabled then
        MethodEnabled.namecall = true
    else
        MethodEnabled.namecall = false
    end
end)

--- window1_tab2
local window1_tab2 = window1:NewTab("settings")
local window1_tab2_section1 = window1_tab2:NewSection("keybinds")

window1_tab2_section1:NewKeybind("toggle ui", "the keybind that toggles the visibility of the ui", Enum.KeyCode.F1, function()
	IU:ToggleUI()
end)

--- window1_tab3
local window1_tab3 = window1:NewTab("credits")
local window1_tab3_section1 = window1_tab3:NewSection("creator: araknala")